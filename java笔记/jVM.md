##JVM
###类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载 这七个阶段，其中验证、准备和解析这三个部分统称为连接（linking）
1. 加载
	* 使用类加载器完成，生成字节码文件，使用类加载器的时候，会有一个双亲委派模型
2. 验证
	* 文件格式验证
	* 元数据验证
	* 字节码验证
	* 符号引用验证
	* 验证对于类加载机制而言，并不是必要的阶段，如果所运行的代码是确保安全的
3. 准备
	* 为类的静态变量分配内存和将其初始化为默认值，这些内存都将在方法区中进行分配。
4. 解析
	* 虚拟机将常量池中的符号引用替换为直接引用的过程
	* 符号引用：一组符号来描述引用的对象
	* 直接引用：能够直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄
5. 初始化
	* 初始化是类加载的最后一步，开始真正的执行类中定义的java程序代码。
	* 初始化阶段是执行类构造器<clinit>()方法的过程。这个方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中（static{}中的语句合并产生的）
6. 使用
7. 卸载

###类的初始化的几种规定情况
1. 创建类的实例
2. 访问类的静态变量（除常量外【被final修饰的静态变量】）原因：常量是一种特殊的变量，编译器将他们当作值（value）而不是域（field）来对待的，如果你的代码中用到了常变量，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。
3. 访问类的静态方法
4. 反射（Class.forName(类名)）
5. 当初始化一个类的时候，发现其父类还没初始化，则先出发父类的初始化
6. 虚拟机启动的时候，定义main()方法的那个类先初始化 

------
* 上面的情况被称为“主动引用”，除这些情况下，均不会出发类的初始化，称为“被动引用”
###被动引用的例子
* 子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。 。 对于静态字段，只有直接定义这个字段的类才会被初始化.
* 通过数组定义来引用类，不会触发类的初始化
* 访问类的常量，不会初始化类


